{
	// Place your 2023 workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"dfs":{
		"scope":"cpp",
		"prefix":"dfs",
		"body":[
			"const int MAX_N = 1e5 + 5;",
			"int vis[MAX_N];",
			"vector<int> adj[MAX_N];",
	
			"void dfs(int u) {",
			"	vis[u] = 1;",
			"	for (int v : adj[u]) {",
			"		if (vis[v]) continue;",
			"		dfs(v);",
			"	}",
			"}",
		],
		"description": "Make DFS"
	},
	"mint":{
		"scope":"cpp",
		"prefix":"mint",
		"body":[
			"template<const int MOD>",
			"struct modint{",
			"	int val;",
			"	modint() {val = 0;}",
			"	modint(const long long& v){",
			"		val = v % MOD;",
			"		if(val < 0) val += MOD;",
			"	}",
			"",
			"	friend ostream& operator<<(ostream& os, const modint& a){return os << a.val;}",
			"	friend bool operator==(const modint& a, const modint& b){return a.val == b.val;}",
			"	friend bool operator!=(const modint& a, const modint& b){return !(a == b);}",
			"	friend bool operator<(const modint& a, const modint& b){return a.val < b.val;}",
			"",
			"	modint operator-() const {return modint(-val);}",
			"	modint& operator+=(const modint& other){",
			"		val += other.val;",
			"		if(val >= MOD) val -= MOD;",
			"		return this;",
			"	}",
			"	modint& operator-=(const modint& other){",
			"		val -= other.val;",
			"		if(val < 0) val += MOD;",
			"		returnthis;",
			"	}",
			"	modint& operator=(const modint& other){",
			"		val = (int)((1LL val * other.val) % MOD);",
			"		return this;",
			"	}",
			"	modint& operator++(){",
			"		val++;",
			"		if(val == MOD) val = 0;",
			"		returnthis;",
			"	}",
			"	modint& operator--(){",
			"		if(val == 0) val = MOD;",
			"		val--;",
			"		return this;",
			"	}",
			"	friend modint modpow(modint a, long long p){",
			"		modint res = 1;",
			"		for(; p; p >>= 1, a= a){",
			"			if(p & 1) res = a;",
			"		}",
			"		return res;",
			"	}",
			"	friend modint inv(const modint& a){return modpow(a, MOD - 2);}",
			"	modint& operator/=(const modint& other){return (this) = inv(other);}",
			"",
			"	friend modint operator+(modint a, const modint& b){return a += b;}",
			"	friend modint operator-(modint a, const modint& b){return a -= b;}",
			"	friend modint operator(modint a, const modint& b){return a *= b;}",
			"	friend modint operator/(modint a, const modint& b){return a /= b;}",
			"	friend modint operator++(modint& a, int){modint r = a; ++a; return r;}",
			"	friend modint operator--(modint& a, int){modint r = a; --a; return r;}",
			"",
			"	operator long long() const{return val;}",
			"};",
		],
		"description": "Mod int template"
	},
	
	"template":{
		"scope":"cpp",
		"prefix":"mouse",
		"body":[
			"#include <iostream>",
			"#include <string>",
			"#include <vector>",
			"#include <algorithm>",
			"#include <sstream>",
			"#include <queue>",
			"#include <deque>",
			"#include <bitset>",
			"#include <iterator>",
			"#include <list>",
			"#include <stack>",
			"#include <map>",
			"#include <set>",
			"#include <functional>",
			"#include <numeric>",
			"#include <utility>",
			"#include <limits>",
			"#include <time.h>",
			"#include <math.h>",
			"#include <stdio.h>",
			"#include <string.h>",
			"#include <stdlib.h>",
			"#include <assert.h>",
			"#include <array>",
			"#include <unordered_map>",
			"#include <unordered_set>",
			"#include <iomanip>",
			"#include <chrono>",
			"#include <random>",
			"#include <climits>",
			"",
			"using namespace std;",
			"#pragma GCC optimize(\"Ofast\")",
			"//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")",
			"#pragma GCC optimize(\"unroll-loops\")",
			"",
			"#define rep(a, b) for(int i = a; i < (b); ++i)",
			"#define rep2(b) for(int i = 0; i < (b); ++i)",
			"#define all(x) begin(x), end(x)",
			"#define sz(x) (int)(x).size()",
			"#define pb(x) push_back(x)",
			"",
			"#define println(x) cout << x << endl;",
			"#define print(x) cout << x << \" \";",
			"",
			"typedef long long ll;",
			"typedef long double ld;",
			"typedef pair<int, int> pii;",
			"typedef vector<int> vi;",
			"typedef vector<ll> vl;",
			"const int MAXA = 1e7;",
			"vector<int> mind(MAXA+1);",
			"vector<int> primes;",
			"",
			"void solve(){",
			"	",
			"}",
			"int main(){",
			"	ios_base::sync_with_stdio(false);",
			"	cin.tie(NULL);",
			"	cout<<setprecision(15)<<fixed;",
			"	int t=1;",
			"	// cin >> t;",
			"	for (int c = 0; c < t; c++)",
			"	{   ",
			"		// cout<<\"Case #\"<<c+1<<\": \";",
			"		solve();",
			"	}",
			"}",
		],
		"description": "Start new CF project"
	},
	"primes":{
		"scope":"cpp",
		"prefix":"prime",
		"body":[
			"for (int i = 2; i <= MAXA; ++i) {",
			"	if (mind[i] == 0) {",
			"		primes.emplace_back(i);",
			"		mind[i] = i;",
			"	}",
			"	for (auto &x : primes) {",
			"		if (x > mind[i] || x * i > MAXA) break;",
			"		mind[x * i] = x;",
			"	}",
			"}",
		],
		"description": "Add primes"
	},
	"dsu":{
		"scope":"cpp",
		"prefix":"dsu",
		"body":[
			"struct dsu{",
			"	int N;",
			"	vector<int> p, s;",
			"	dsu(int _n){",
			"		N = _n + 5;",
			"		p.resize(N); s.resize(N);",
			"		iota(p.begin(), p.end(), 0);",
			"		fill(s.begin(), s.end(), 1);",
			"	}",
			"	int size(int a){",
			"		return s[find(a)];",
			"	}",
			"	int find(int a){",
			"		if(p[a] == a) return a;",
			"		p[a] = find(p[a]);",
			"		return p[a];",
			"	}",
			"	bool unite(int a, int b){",
			"		a = find(a), b = find(b);",
			"		if(a == b) return false;",
			"		if(s[a] > s[b]) swap(a, b);",
			"		s[b] += s[a];",
			"		p[a] = b;",
			"		return true;",
			"	}",
			"	bool same(int a, int b){",
			"		return find(a) == find(b);",
			"	}",
			"};",
		]
	}
}

